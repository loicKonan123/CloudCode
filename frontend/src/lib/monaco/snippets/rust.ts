import type { LanguageSnippet } from '../types';

export const rustSnippets: LanguageSnippet[] = [
  {
    label: 'if statement',
    prefix: 'if',
    body: 'if ${1:condition} {\n\t${2}\n}',
    description: 'if statement',
  },
  {
    label: 'if-else statement',
    prefix: 'ife',
    body: 'if ${1:condition} {\n\t${2}\n} else {\n\t${3}\n}',
    description: 'if-else statement',
  },
  {
    label: 'if let',
    prefix: 'iflet',
    body: 'if let ${1:Some(x)} = ${2:option} {\n\t${3}\n}',
    description: 'if let expression',
  },
  {
    label: 'for loop',
    prefix: 'for',
    body: 'for ${1:item} in ${2:iterator} {\n\t${3}\n}',
    description: 'for loop',
  },
  {
    label: 'for range',
    prefix: 'forr',
    body: 'for ${1:i} in 0..${2:n} {\n\t${3}\n}',
    description: 'for range loop',
  },
  {
    label: 'while loop',
    prefix: 'while',
    body: 'while ${1:condition} {\n\t${2}\n}',
    description: 'while loop',
  },
  {
    label: 'while let',
    prefix: 'whilelet',
    body: 'while let ${1:Some(x)} = ${2:iterator.next()} {\n\t${3}\n}',
    description: 'while let loop',
  },
  {
    label: 'loop',
    prefix: 'loop',
    body: 'loop {\n\t${1}\n}',
    description: 'infinite loop',
  },
  {
    label: 'match',
    prefix: 'match',
    body: 'match ${1:expression} {\n\t${2:pattern} => ${3:result},\n\t_ => ${4:default},\n}',
    description: 'match expression',
  },
  {
    label: 'match option',
    prefix: 'matchopt',
    body: 'match ${1:option} {\n\tSome(${2:x}) => ${3},\n\tNone => ${4},\n}',
    description: 'match Option',
  },
  {
    label: 'match result',
    prefix: 'matchres',
    body: 'match ${1:result} {\n\tOk(${2:x}) => ${3},\n\tErr(${4:e}) => ${5},\n}',
    description: 'match Result',
  },
  {
    label: 'function',
    prefix: 'fn',
    body: 'fn ${1:name}(${2:params}) -> ${3:ReturnType} {\n\t${4}\n}',
    description: 'function definition',
  },
  {
    label: 'function no return',
    prefix: 'fnv',
    body: 'fn ${1:name}(${2:params}) {\n\t${3}\n}',
    description: 'function without return',
  },
  {
    label: 'main function',
    prefix: 'main',
    body: 'fn main() {\n\t${1}\n}',
    description: 'main function',
  },
  {
    label: 'struct',
    prefix: 'struct',
    body: 'struct ${1:Name} {\n\t${2:field}: ${3:Type},\n}',
    description: 'struct definition',
  },
  {
    label: 'impl',
    prefix: 'impl',
    body: 'impl ${1:Type} {\n\t${2}\n}',
    description: 'impl block',
  },
  {
    label: 'impl trait',
    prefix: 'implt',
    body: 'impl ${1:Trait} for ${2:Type} {\n\t${3}\n}',
    description: 'impl trait for type',
  },
  {
    label: 'trait',
    prefix: 'trait',
    body: 'trait ${1:Name} {\n\tfn ${2:method}(&self) -> ${3:ReturnType};\n}',
    description: 'trait definition',
  },
  {
    label: 'enum',
    prefix: 'enum',
    body: 'enum ${1:Name} {\n\t${2:Variant1},\n\t${3:Variant2},\n}',
    description: 'enum definition',
  },
  {
    label: 'Result type',
    prefix: 'result',
    body: 'Result<${1:T}, ${2:E}>',
    description: 'Result type',
  },
  {
    label: 'Option type',
    prefix: 'option',
    body: 'Option<${1:T}>',
    description: 'Option type',
  },
  {
    label: 'println!',
    prefix: 'pl',
    body: 'println!("${1}");',
    description: 'println! macro',
  },
  {
    label: 'println! with format',
    prefix: 'plf',
    body: 'println!("${1}: {:?}", ${2});',
    description: 'println! with debug format',
  },
  {
    label: 'vec!',
    prefix: 'vec',
    body: 'let ${1:v} = vec![${2}];',
    description: 'vec! macro',
  },
  {
    label: 'use',
    prefix: 'use',
    body: 'use ${1:std::collections::HashMap};',
    description: 'use statement',
  },
  {
    label: 'mod',
    prefix: 'mod',
    body: 'mod ${1:name} {\n\t${2}\n}',
    description: 'module definition',
  },
  {
    label: 'pub fn',
    prefix: 'pubfn',
    body: 'pub fn ${1:name}(${2:params}) -> ${3:ReturnType} {\n\t${4}\n}',
    description: 'public function',
  },
  {
    label: 'test',
    prefix: 'test',
    body: '#[test]\nfn ${1:test_name}() {\n\t${2}\n}',
    description: 'test function',
  },
  {
    label: 'derive',
    prefix: 'derive',
    body: '#[derive(${1:Debug, Clone})]',
    description: 'derive attribute',
  },
];
