import type { LanguageSnippet } from '../types';

export const rubySnippets: LanguageSnippet[] = [
  {
    label: 'if statement',
    prefix: 'if',
    body: 'if ${1:condition}\n\t${2}\nend',
    description: 'if statement',
  },
  {
    label: 'if-else statement',
    prefix: 'ife',
    body: 'if ${1:condition}\n\t${2}\nelse\n\t${3}\nend',
    description: 'if-else statement',
  },
  {
    label: 'if-elsif-else',
    prefix: 'ifel',
    body: 'if ${1:condition}\n\t${2}\nelsif ${3:condition}\n\t${4}\nelse\n\t${5}\nend',
    description: 'if-elsif-else statement',
  },
  {
    label: 'unless',
    prefix: 'unless',
    body: 'unless ${1:condition}\n\t${2}\nend',
    description: 'unless statement',
  },
  {
    label: 'ternary',
    prefix: 'tern',
    body: '${1:condition} ? ${2:true_value} : ${3:false_value}',
    description: 'ternary operator',
  },
  {
    label: 'for loop',
    prefix: 'for',
    body: 'for ${1:item} in ${2:collection}\n\t${3}\nend',
    description: 'for loop',
  },
  {
    label: 'each',
    prefix: 'each',
    body: '${1:collection}.each do |${2:item}|\n\t${3}\nend',
    description: 'each iterator',
  },
  {
    label: 'each with index',
    prefix: 'eachi',
    body: '${1:collection}.each_with_index do |${2:item}, ${3:index}|\n\t${4}\nend',
    description: 'each with index',
  },
  {
    label: 'times',
    prefix: 'times',
    body: '${1:n}.times do |${2:i}|\n\t${3}\nend',
    description: 'times iterator',
  },
  {
    label: 'while loop',
    prefix: 'while',
    body: 'while ${1:condition}\n\t${2}\nend',
    description: 'while loop',
  },
  {
    label: 'until loop',
    prefix: 'until',
    body: 'until ${1:condition}\n\t${2}\nend',
    description: 'until loop',
  },
  {
    label: 'case statement',
    prefix: 'case',
    body: 'case ${1:expression}\nwhen ${2:value}\n\t${3}\nelse\n\t${4}\nend',
    description: 'case statement',
  },
  {
    label: 'method definition',
    prefix: 'def',
    body: 'def ${1:method_name}(${2:params})\n\t${3}\nend',
    description: 'method definition',
  },
  {
    label: 'class definition',
    prefix: 'class',
    body: 'class ${1:ClassName}\n\tdef initialize(${2:params})\n\t\t${3}\n\tend\nend',
    description: 'class definition',
  },
  {
    label: 'class with inheritance',
    prefix: 'classi',
    body: 'class ${1:ClassName} < ${2:BaseClass}\n\tdef initialize(${3:params})\n\t\tsuper(${4})\n\t\t${5}\n\tend\nend',
    description: 'class with inheritance',
  },
  {
    label: 'module',
    prefix: 'module',
    body: 'module ${1:ModuleName}\n\t${2}\nend',
    description: 'module definition',
  },
  {
    label: 'begin-rescue',
    prefix: 'begin',
    body: 'begin\n\t${1}\nrescue ${2:StandardError} => ${3:e}\n\t${4}\nend',
    description: 'begin-rescue block',
  },
  {
    label: 'begin-rescue-ensure',
    prefix: 'begine',
    body: 'begin\n\t${1}\nrescue ${2:StandardError} => ${3:e}\n\t${4}\nensure\n\t${5}\nend',
    description: 'begin-rescue-ensure block',
  },
  {
    label: 'block',
    prefix: 'block',
    body: 'do |${1:params}|\n\t${2}\nend',
    description: 'block',
  },
  {
    label: 'lambda',
    prefix: 'lambda',
    body: '->(${1:params}) { ${2} }',
    description: 'lambda expression',
  },
  {
    label: 'proc',
    prefix: 'proc',
    body: 'Proc.new { |${1:params}| ${2} }',
    description: 'proc',
  },
  {
    label: 'attr_accessor',
    prefix: 'attr',
    body: 'attr_accessor :${1:name}',
    description: 'attr_accessor',
  },
  {
    label: 'attr_reader',
    prefix: 'attrr',
    body: 'attr_reader :${1:name}',
    description: 'attr_reader',
  },
  {
    label: 'attr_writer',
    prefix: 'attrw',
    body: 'attr_writer :${1:name}',
    description: 'attr_writer',
  },
  {
    label: 'puts',
    prefix: 'puts',
    body: 'puts ${1}',
    description: 'puts statement',
  },
  {
    label: 'require',
    prefix: 'require',
    body: "require '${1:library}'",
    description: 'require statement',
  },
  {
    label: 'require_relative',
    prefix: 'requirerel',
    body: "require_relative '${1:file}'",
    description: 'require_relative statement',
  },
  {
    label: 'map',
    prefix: 'map',
    body: '${1:collection}.map { |${2:item}| ${3} }',
    description: 'map method',
  },
  {
    label: 'select',
    prefix: 'select',
    body: '${1:collection}.select { |${2:item}| ${3} }',
    description: 'select method',
  },
  {
    label: 'reduce',
    prefix: 'reduce',
    body: '${1:collection}.reduce(${2:initial}) { |${3:acc}, ${4:item}| ${5} }',
    description: 'reduce method',
  },
];
