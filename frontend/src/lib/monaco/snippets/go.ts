import type { LanguageSnippet } from '../types';

export const goSnippets: LanguageSnippet[] = [
  {
    label: 'if statement',
    prefix: 'if',
    body: 'if ${1:condition} {\n\t${2}\n}',
    description: 'if statement',
  },
  {
    label: 'if-else statement',
    prefix: 'ife',
    body: 'if ${1:condition} {\n\t${2}\n} else {\n\t${3}\n}',
    description: 'if-else statement',
  },
  {
    label: 'if with initialization',
    prefix: 'ifi',
    body: 'if ${1:init}; ${2:condition} {\n\t${3}\n}',
    description: 'if with initialization',
  },
  {
    label: 'if err != nil',
    prefix: 'iferr',
    body: 'if err != nil {\n\treturn ${1:err}\n}',
    description: 'if error check',
  },
  {
    label: 'for loop',
    prefix: 'for',
    body: 'for ${1:i} := 0; ${1:i} < ${2:n}; ${1:i}++ {\n\t${3}\n}',
    description: 'for loop',
  },
  {
    label: 'for range',
    prefix: 'forr',
    body: 'for ${1:i}, ${2:v} := range ${3:collection} {\n\t${4}\n}',
    description: 'for range loop',
  },
  {
    label: 'for infinite',
    prefix: 'fori',
    body: 'for {\n\t${1}\n}',
    description: 'infinite for loop',
  },
  {
    label: 'switch statement',
    prefix: 'switch',
    body: 'switch ${1:expression} {\ncase ${2:value}:\n\t${3}\ndefault:\n\t${4}\n}',
    description: 'switch statement',
  },
  {
    label: 'switch type',
    prefix: 'switcht',
    body: 'switch ${1:v} := ${2:x}.(type) {\ncase ${3:Type}:\n\t${4}\ndefault:\n\t${5}\n}',
    description: 'type switch',
  },
  {
    label: 'function',
    prefix: 'func',
    body: 'func ${1:name}(${2:params}) ${3:returnType} {\n\t${4}\n}',
    description: 'function definition',
  },
  {
    label: 'function with error',
    prefix: 'funce',
    body: 'func ${1:name}(${2:params}) (${3:returnType}, error) {\n\t${4}\n}',
    description: 'function returning error',
  },
  {
    label: 'method',
    prefix: 'method',
    body: 'func (${1:r} *${2:Receiver}) ${3:name}(${4:params}) ${5:returnType} {\n\t${6}\n}',
    description: 'method definition',
  },
  {
    label: 'main function',
    prefix: 'main',
    body: 'func main() {\n\t${1}\n}',
    description: 'main function',
  },
  {
    label: 'main package',
    prefix: 'pmain',
    body: 'package main\n\nimport (\n\t"fmt"\n)\n\nfunc main() {\n\t${1}\n}',
    description: 'main package with imports',
  },
  {
    label: 'struct',
    prefix: 'struct',
    body: 'type ${1:Name} struct {\n\t${2:Field} ${3:Type}\n}',
    description: 'struct definition',
  },
  {
    label: 'interface',
    prefix: 'interface',
    body: 'type ${1:Name} interface {\n\t${2:Method}(${3}) ${4}\n}',
    description: 'interface definition',
  },
  {
    label: 'goroutine',
    prefix: 'go',
    body: 'go func() {\n\t${1}\n}()',
    description: 'goroutine',
  },
  {
    label: 'defer',
    prefix: 'defer',
    body: 'defer ${1:func}()',
    description: 'defer statement',
  },
  {
    label: 'channel',
    prefix: 'chan',
    body: '${1:ch} := make(chan ${2:Type})',
    description: 'channel creation',
  },
  {
    label: 'select',
    prefix: 'select',
    body: 'select {\ncase ${1:msg} := <-${2:ch}:\n\t${3}\ndefault:\n\t${4}\n}',
    description: 'select statement',
  },
  {
    label: 'map',
    prefix: 'map',
    body: '${1:m} := make(map[${2:KeyType}]${3:ValueType})',
    description: 'map creation',
  },
  {
    label: 'slice',
    prefix: 'slice',
    body: '${1:s} := make([]${2:Type}, ${3:0})',
    description: 'slice creation',
  },
  {
    label: 'fmt.Println',
    prefix: 'pl',
    body: 'fmt.Println(${1})',
    description: 'fmt.Println',
  },
  {
    label: 'fmt.Printf',
    prefix: 'pf',
    body: 'fmt.Printf("${1:%v}\\n", ${2})',
    description: 'fmt.Printf',
  },
  {
    label: 'import',
    prefix: 'import',
    body: 'import (\n\t"${1:fmt}"\n)',
    description: 'import statement',
  },
  {
    label: 'package',
    prefix: 'package',
    body: 'package ${1:main}',
    description: 'package declaration',
  },
  {
    label: 'test function',
    prefix: 'test',
    body: 'func Test${1:Name}(t *testing.T) {\n\t${2}\n}',
    description: 'test function',
  },
  {
    label: 'benchmark',
    prefix: 'bench',
    body: 'func Benchmark${1:Name}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${2}\n\t}\n}',
    description: 'benchmark function',
  },
];
